{
    parserClass="com.intellij.plugins.haxe.lang.parser.HaxeParser"
    stubParserClass="com.intellij.plugins.haxe.lang.parser.GeneratedParserUtilBase"

    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiCompositeElement"
    extends="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiCompositeElementImpl"

    psiClassPrefix="Haxe"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.plugins.haxe.lang.psi"
    psiImplPackage="com.intellij.plugins.haxe.lang.psi.impl"

    elementTypeHolderClass="com.intellij.plugins.haxe.lang.lexer.HaxeTokenTypes"
    elementTypePrefix=""
    elementTypeClass="com.intellij.plugins.haxe.lang.lexer.HaxeElementType"
    tokenTypeClass="com.intellij.plugins.haxe.lang.lexer.HaxeElementType"

    pLCURLY="{"
    pRCURLY="}"
    pLBRACK="["
    pRBRACK="]"
    pLPAREN="("
    pRPAREN=")"
    oCOLON=":"
    oSEMI=";"
    oCOMMA=","
    oDOT="."
    oEQ="=="
    oASSIGN="="
    oNOT_EQ="!="
    oNOT="!"
    oCOMPLEMENT="~"
    oPLUS_PLUS="++"
    oPLUS_ASSIGN="+="
    oPLUS="+"
    oMINUS_MINUS="--"
    oMINUS_ASSIGN="-="
    oMINUS="-"

    oQUEST="?"

    oCOND_OR="||"
    oBIT_OR="|"
    oBIT_OR_ASSIGN="|="

    oCOND_AND="&&"

    oBIT_AND_ASSIGN="&="
    oBIT_AND="&"

    oSHIFT_LEFT_ASSIGN="<<="
    oSHIFT_LEFT="<<"
    oLESS_OR_EQUAL="<="
    oLESS="<"

    oBIT_XOR_ASSIGN="^="
    oBIT_XOR="^"

    oMUL_ASSIGN="*="
    oMUL="*"

    oQUOTIENT_ASSIGN="/="
    oQUOTIENT="/"

    oREMAINDER_ASSIGN="%="
    oREMAINDER="%"

    oSHIFT_RIGHT_ASSIGN=">>="
    oSHIFT_RIGHT=">>"
    oUNSIGNED_SHIFT_RIGHT=">>>"
    oGREATER_OR_EQUAL=">="
    oGREATER=">"

    oTRIPLE_DOT="..."
    OIN='in'

    oNEW="new"

    ppIF="#if"
    ppELSE="#else"
    ppELSEIF="#elseif"
    ppEND="#end"
    ppERROR="#error"

    kBREAK="break"
    kDEFAULT="default"
    kPACKAGE="package"
    kFUNCTION="function"

    kCASE="case"
    kCAST="cast"

    kCLASS="class"
    kENUM="enum"
    kINTERFACE="interface"

    kIMPLEMENTS="implements"
    kEXTENDS="extends"

    kNULL ="null"
    kTHIS ="this"

    kIF ="if"
    kFOR ="for"
    kDO ="do"
    kWHILE ="while"
    kRETURN="return"
    kIMPORT ="import"
    kCONTINUE ="continue"
    kELSE ="else"
    kSWITCH ="switch"
    kTHROW ="throw"

    kVAR="var"
    kSTATIC="static"
    kPUBLIC="public"
    kPRIVATE="private"
    kDYNAMIC="dynamic"
    kOVERRIDE="override"
    kINLINE="inline"

    kUNTYPE="untyped"

    elementTypeHolderClass="org.intellij.grammar.psi.HaxeTypes"
    elementTypePrefix="HAXE_"
    elementTypeClass="org.intellij.grammar.psi.HaxeCompositeElementType"
    tokenTypeClass="org.intellij.grammar.psi.HaxeTokenType"

    extends(".*(Expression|Literal)")="expression"
    pin(".*Expression")=1

    extends(".*Statement")="statement"
    pin(".*Statement")=1
}

haxeFile ::= packageStatement? topLevelList

assignOperation ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '>>>='
compareOperation ::= '==' | '!=' | '<=' | '<' | '>' | '>='
bitOperation ::= '|' | '&' | '^'
shiftOperator ::= '>>' | '<<' | '>>>'


packageStatement ::= 'package' simpleQualifiedReferenceExpression? ';' {pin=1}

topLevelList ::= topLevel+
topLevel ::= importStatement | pp | topLevelDeclaration

importStatement ::= 'import' simpleQualifiedReferenceExpression ';' {pin=1}

pp ::= ppIf | ppElseIf | ppElse | ppEnd | ppError
ppIf ::= '#if' ternaryExpressionWrapper {pin=1}
ppElseIf ::= '#elseif' ternaryExpressionWrapper {pin=1}
ppElse ::= '#else' {pin=1}
ppEnd  ::= '#end' {pin=1}
ppError ::= '#error' {pin=1}

topLevelDeclaration ::= classDeclaration
                      | interfaceDeclaration
                      | enumDeclaration
                      | typedefDeclaration

typedefDeclaration ::= 'typedef' ID typeParam? '=' functionType ';'? {pin=1 recoverUntil="typedef_recover"}
private typedef_recover ::= !topLevel

classDeclaration ::= 'class' ID typeParam? inheritList? '{' classBody '}' {pin=1}
classBody ::= (varDeclaration | functionDeclarationWithAttributes | pp)*

interfaceDeclaration ::= 'interface' type inheritList? '{' interfaceBody '}' {pin=1}
interfaceBody ::= (varDeclaration | functionDeclarationWithAttributes | pp)*

enumDeclaration ::= 'enum' ID typeParam? '{' enumBody '}' {pin=1}
enumBody ::= enumValueDeclaration+

/*
 *  declarations
 */

access ::= 'public' | 'private'
declarationAttribute ::= 'static' | 'inline' | 'dynamic' | 'override' | access
declarationAttributeList ::= declarationAttribute+

enumValueDeclaration ::= pp | (ID enumConstructorParameters? ';')
enumConstructorParameters ::= '(' parameterList? ')' {pin=1}

varDeclarationList ::= varDeclaration+
varDeclaration ::= declarationAttributeList? 'var' varDeclarationPartList ';' {pin=2}
private varDeclarationPartList ::= varDeclarationPart (',' varDeclarationPart)*
varDeclarationPart ::= ID propertyDeclaration? typeTag? varInit? {recoverUntil="var_declaration_part_recover"}
private var_declaration_part_recover ::= !(';' | ',')

localVarDeclaration ::= 'var' localVarDeclarationPartList ';'? {pin=1}
private localVarDeclarationPartList ::= localVarDeclarationPart (',' localVarDeclarationPart)*
localVarDeclarationPart ::= ID propertyDeclaration? typeTag? varInit? {recoverUntil="local_var_declaration_part_recover"}
private local_var_declaration_part_recover ::= !(';' | ',' | statement)

propertyDeclaration ::= '(' propertyAccessor ',' propertyAccessor ')'

propertyAccessor ::= ID | 'null' | 'default' | 'dynamic'

functionDeclarationWithAttributes ::= declarationAttributeList? 'function' ('new' | ID typeParam?) '(' parameterList? ')' typeTag? (blockStatement | ';' | returnStatementWithoutSemicolon) {pin=3}
localFunctionDeclaration ::= 'function' ID typeParam? '(' parameterList? ')' typeTag? (blockStatement | returnStatementWithoutSemicolon) {pin=2}

/*
 *
 */

varInit ::= '=' expression {pin=1}
parameter ::= '?'? ID typeTag? varInit?
parameterList ::= parameter (',' parameter)* {recoverUntil="parameterListRecovery"}
private parameterListRecovery ::= !')' // after parameterList always ')'

functionLiteral ::= 'function' '(' parameterList? ')' typeTag? (blockStatement | returnStatementWithoutSemicolon) {pin=2}
arrayLiteral ::= '[' expressionList? ']'

functionType ::= typeOrAnonymous ('->' typeOrAnonymous)*

typeTag ::= ':' functionType
typeParam ::= '<' typeList '>'
typeList ::= (typeConstraint | functionType) (',' typeList)*
type ::= referenceExpression typeParam? {extends="functionType"}
private typeOrAnonymous ::= type | anonymousType
typeConstraint ::= ID ':' '(' typeList ')' {pin=3}

blockStatement ::= '{' statementList? '}'
private statementList ::= (statement ';'?)+

statement ::= blockStatement | notBlockStatement {recoverUntil="statement_recovery"}
private statement_recovery ::= !(statement | ';' | '{' | '}' | ')' | 'else' | 'while')

private notBlockStatement ::= ('untyped' statement)
                            | localVarDeclaration
                            | localFunctionDeclaration
                            | ifStatement
                            | forStatement
                            | whileStatement
                            | doWhileStatement
                            | returnStatement
                            | breakStatement
                            | continueStatement
                            | caseStatement
                            | defaultStatement
                            | switchStatement
                            | throwStatement
                            | tryStatement
                            | (expression ';'?)
                            | pp

ifStatement ::= 'if' '(' expression ')' statement ('else' statement)?
ifExpression ::= 'if' '(' expression ')' expression ('else' expression)?

forStatement ::= 'for' '(' expression 'in' expression ')' statement

whileStatement ::= 'while' '(' expression ')' statement
doWhileStatement ::= 'do' statement 'while' '(' expression ')'

returnStatement ::= 'return' expression? ';'
returnStatementWithoutSemicolon ::= 'return' expression

breakStatement ::= 'break' ';'
continueStatement ::= 'continue' ';'
defaultStatement ::= 'default' ':'

throwStatement ::= 'throw' expression ';'
caseStatement ::= 'case' expressionList ':'

switchStatement ::= 'switch' '(' expression ')' blockStatement
tryStatement ::= 'try' blockStatement catchStatement*
catchStatement ::= 'catch' '(' parameter ')' blockStatement

/*
 * expressions
 */

expressionList ::= expression (',' expression)*

expression ::= assignExpressionWrapper

private assignExpressionWrapper ::= iteratorExpressionWrapper assignExpression*
left assignExpression ::= assignOperation iteratorExpressionWrapper {pin=1 extends="expression"}

private iteratorExpressionWrapper ::= ternaryExpressionWrapper iteratorExpression?
left iteratorExpression ::= '...' ternaryExpressionWrapper

private ternaryExpressionWrapper ::= logicOrExpressionWrapper ternaryExpression?
left ternaryExpression ::= '?' expression ':' ternaryExpressionWrapper

private logicOrExpressionWrapper ::= logicAndExpressionWrapper logicOrExpression*
left logicOrExpression ::= '||' logicAndExpressionWrapper

private logicAndExpressionWrapper ::= compareExpressionWrapper logicAndExpression*
left logicAndExpression ::= '&&' compareExpressionWrapper

private compareExpressionWrapper ::= bitwiseExpressionWrapper compareExpression*
left compareExpression ::= compareOperation bitwiseExpressionWrapper

private bitwiseExpressionWrapper ::= shiftExpressionWrapper bitwiseExpression*
left bitwiseExpression ::= bitOperation shiftExpressionWrapper

private shiftExpressionWrapper ::= additiveExpressionWrapper shiftExpression*
left shiftExpression ::= shiftOperator additiveExpressionWrapper

private additiveExpressionWrapper ::= multiplicativeExpressionWrapper additiveExpression*
left additiveExpression ::= ('+' | '-') multiplicativeExpressionWrapper

private multiplicativeExpressionWrapper ::= prefixExpression multiplicativeExpression*
left multiplicativeExpression ::= ('*' | '/' | '%') (prefixExpression | suffixExpressionWrapper)

prefixExpression ::= ('-' | '--' | '++' | '!' | '~') prefixExpression | suffixExpressionWrapper

private suffixExpressionWrapper ::= value suffixExpression*
left suffixExpression ::= ('--' | '++')

private value ::= literalExpression
                | ifExpression
                | castExpression
                | newExpressionOrCall
                | parenthesizedExpressionOrCall
                | callOrArrayAccess

literalExpression ::= LITINT | LITHEX | LITOCT | LITFLOAT | LITSTRING | LITCHAR
                    | 'null'
                    | functionLiteral
                    | arrayLiteral
                    | objectLiteral

private parenthesizedExpressionOrCall ::= parenthesizedExpression (qualifiedReferenceExpression (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*)?
parenthesizedExpression ::= '(' (expression | statement) ')'

private newExpressionOrCall ::= newExpression (qualifiedReferenceExpression (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*)?

private callOrArrayAccess ::= (referenceExpression | thisExpression) (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*

left callExpression ::= '(' expressionList? ')'
left arrayAccessExpression ::= '[' expression? ']'

referenceExpression ::= identifier {mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"}
left qualifiedReferenceExpression ::= '.' identifier {extends="referenceExpression" elementType="referenceExpression"}
simpleQualifiedReferenceExpression ::= referenceExpression qualifiedReferenceExpression * {elementType="referenceExpression"}
identifier ::=  ID

thisExpression ::= 'this'

newExpression ::= 'new' type '(' expressionList? ')' {pin=2}

castExpression ::= 'cast' (expression | ( '(' expression (',' functionType)? ')' ))

inheritList ::= inherit (',' inherit)*

inherit ::= ('extends' | 'implements') type {pin=1}

anonymousType ::= '{' typeExtends? (varDeclarationList | anonymousTypeFieldList)? '}' {extends="functionType"}

typeExtends ::= '>' functionType ','

anonymousTypeFieldList ::= anonymousTypeField (',' anonymousTypeField )*

anonymousTypeField ::= ID ':' functionType

objectLiteral ::= '{' objectLiteralElementList '}'

private objectLiteralElementList ::= objectLiteralElement (',' objectLiteralElement)*

objectLiteralElement ::= ID ':' expression







