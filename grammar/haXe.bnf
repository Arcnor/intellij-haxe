{
    parserClass="com.intellij.plugins.haxe.lang.parser.HaxeParser"
    stubParserClass="com.intellij.plugins.haxe.lang.parser.GeneratedParserUtilBase"

    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiCompositeElement"
    extends="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiCompositeElementImpl"

    psiClassPrefix="Haxe"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.plugins.haxe.lang.psi"
    psiImplPackage="com.intellij.plugins.haxe.lang.psi.impl"

    elementTypeHolderClass="com.intellij.plugins.haxe.lang.lexer.HaxeTokenTypes"
    elementTypePrefix=""
    elementTypeClass="com.intellij.plugins.haxe.lang.lexer.HaxeElementType"
    tokenTypeClass="com.intellij.plugins.haxe.lang.lexer.HaxeElementType"

    generateFirstCheck=50

    pLCURLY="{"
    pRCURLY="}"
    pLBRACK="["
    pRBRACK="]"
    pLPAREN="("
    pRPAREN=")"
    oCOLON=":"
    oSEMI=";"
    oCOMMA=","
    oDOT="."
    oEQ="=="
    oASSIGN="="
    oNOT_EQ="!="
    oNOT="!"
    oCOMPLEMENT="~"
    oPLUS_PLUS="++"
    oPLUS_ASSIGN="+="
    oPLUS="+"
    oMINUS_MINUS="--"
    oMINUS_ASSIGN="-="
    oMINUS="-"

    oQUEST="?"

    oCOND_OR="||"
    oBIT_OR="|"
    oBIT_OR_ASSIGN="|="

    oCOND_AND="&&"

    oBIT_AND_ASSIGN="&="
    oBIT_AND="&"

    oSHIFT_LEFT_ASSIGN="<<="
    oSHIFT_LEFT="<<"
    oLESS_OR_EQUAL="<="
    oLESS="<"

    oBIT_XOR_ASSIGN="^="
    oBIT_XOR="^"

    oMUL_ASSIGN="*="
    oMUL="*"

    oQUOTIENT_ASSIGN="/="
    oQUOTIENT="/"

    oREMAINDER_ASSIGN="%="
    oREMAINDER="%"

    oSHIFT_RIGHT_ASSIGN=">>="
    oGREATER_OR_EQUAL=">="
    oGREATER=">"

    oTRIPLE_DOT="..."
    OIN='in'
    OARROW='->'

    oNEW="new"

    ppIF="#if"
    ppELSE="#else"
    ppELSEIF="#elseif"
    ppEND="#end"
    ppERROR="#error"

    kBREAK="break"
    kDEFAULT="default"
    kPACKAGE="package"
    kFUNCTION="function"

    kCASE="case"
    kCAST="cast"

    kCLASS="class"
    kENUM="enum"
    kINTERFACE="interface"

    kIMPLEMENTS="implements"
    kEXTENDS="extends"

    kNULL ="null"
    kTRUE ="true"
    kFALSE ="false"
    kTHIS ="this"
    kSUPER ="super"

    kIF ="if"
    kFOR ="for"
    kDO ="do"
    kWHILE ="while"
    kRETURN="return"
    kIMPORT ="import"
    kUSING ="using"
    kCONTINUE ="continue"
    kELSE ="else"
    kSWITCH ="switch"
    kTHROW ="throw"

    kVAR="var"
    kSTATIC="static"
    kPUBLIC="public"
    kPRIVATE="private"
    kDYNAMIC="dynamic"
    kNEVER="never"
    kOVERRIDE="override"
    kINLINE="inline"

    kUNTYPED="untyped"
    kTYPEDEF="typedef"

    kEXTERN="extern"
    kFINAL="@:final"
    kHACK="@:hack"
    kNATIVE="@:native"
    kMACRO="@:macro"
    kBUILD="@:build"
    kAUTOBUILD="@:autoBuild"
    kKEEP="@:keep"
    kREQUIRE="@:require"
    kFAKEENUM="@:fakeEnum"
    kCOREAPI="@:core_api"

    kBIND="@:bind"
    kBITMAP="@:bitmap"
    kNS="@:ns"
    kPROTECTED="@:protected"
    kGETTER="@:getter"
    kSETTER="@:setter"
    kDEBUG="@:debug"
    kNODEBUG="@:nodebug"
    kMETA="@:meta"
    kOVERLOAD="@:overload"

    kTRY="try"
    kCATCH="catch"

    elementTypePrefix="HAXE_"

    extends(".*(Expression|Literal)")="expression"
    pin(".*Expression")=1
    pin(".*Statement")=1
    pin(".*Meta")=1
}

haxeFile ::= packageStatement? topLevelList

/*
  http://haxe.org/manual/metadata
  http://haxe.org/manual/tips_and_tricks
*/
private macroClass ::= '@:final' | '@:core_api' | '@:bind' | '@:macro' | '@:hack'
                      | requireMeta | fakeEnumMeta | nativeMeta | bitmapMeta | nsMeta | customMeta | metaMeta | buildMacro | autoBuildMacro

private functionMacroMember ::= macroMember | overloadMeta
private macroMember ::= '@:macro' | '@:keep' | '@:protected' | '@:debug' | '@:nodebug'
                       | requireMeta | nsMeta | getterMeta | setterMeta | customMeta | buildMacro | autoBuildMacro

buildMacro ::= '@:build' '(' referenceExpression (callExpression | arrayAccessExpression | qualifiedReferenceExpression)* ')' {pin=2}
autoBuildMacro ::= '@:autoBuild' '(' referenceExpression (callExpression | arrayAccessExpression | qualifiedReferenceExpression)* ')' {pin=2}
requireMeta ::=  '@:require' '(' identifier ')'
fakeEnumMeta ::=  '@:fakeEnum' '(' type ')'
nativeMeta ::=  '@:native' '(' LITSTRING ')'
bitmapMeta ::= '@:bitmap' '(' LITSTRING ')'
nsMeta ::= '@:ns' '(' LITSTRING ')'
getterMeta ::= '@:getter' '(' referenceExpression ')'
setterMeta ::= '@:setter' '(' referenceExpression ')'
overloadMeta ::= '@:overload' '(' anonymousFunctionDeclaration ')'
customMeta ::= MACRO_ID ('(' customMetaLiterals ')')?
private customMetaLiterals ::= literalExpression (',' literalExpression)*
metaMeta ::= '@:meta' '(' ID '(' metaPartList ')' ')'
private metaPartList ::= metaKeyValue (',' metaKeyValue)*
metaKeyValue ::= ID '=' LITSTRING

assignOperation ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '>>>='
compareOperation ::= '==' | '!=' | '<=' | '<' | '>' | '>='
bitOperation ::= '|' | '&' | '^'
shiftOperator ::= unsignedShiftRightOperator | shiftRightOperator | '<<'

shiftRightOperator ::= '>' '>'
unsignedShiftRightOperator ::= '>' '>' '>'

packageStatement ::= 'package' simpleQualifiedReferenceExpression? ';' {pin=1}

private topLevelList ::= topLevel*
private topLevel ::= importStatement | usingStatement | pp | topLevelDeclaration {recoverUntil="top_level_recover"}
private top_level_recover ::= !('#else' | '#elseif' | '#end' | '#error' | '#if' | '@:bind' | '@:bitmap' | '@:build' | '@:autoBuild' | '@:core_api' | '@:fakeEnum' | '@:final' | '@:hack' | '@:overload' | '@:macro' | '@:meta' | '@:native' | '@:ns' | '@:require' | 'class' | 'enum' | 'extern' | 'import' | 'using' | 'interface' | 'private' | 'typedef' | MACRO_ID)

importStatement ::= 'import' simpleQualifiedReferenceExpression ';' {pin=1}
usingStatement ::= 'using' simpleQualifiedReferenceExpression ';' {pin=1}

pp ::= ppIf | ppElseIf | ppElse | ppEnd | ppError
ppIf ::= '#if' logicOrExpressionWrapper {pin=1}
ppElseIf ::= '#elseif' logicOrExpressionWrapper {pin=1}
ppElse ::= '#else'
ppEnd  ::= '#end'
ppError ::= '#error'

private topLevelDeclaration ::= classDeclaration
                              | externClassDeclaration
                              | interfaceDeclaration
                              | enumDeclaration
                              | typedefDeclaration

externOrPrivate ::= 'extern' | 'private'

typedefDeclaration ::= externOrPrivate? 'typedef' componentName genericParam? '=' functionTypeWrapper ';'?
{pin=2 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeTypeDefImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"}

externClassDeclaration ::= macroClass* 'extern' 'class' componentName genericParam? inheritList? '{' externClassDeclarationBody '}'
{pin=3 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass" implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"}
externClassDeclarationBody ::= externClassDeclarationBodyPart*
private externClassDeclarationBodyPart ::= varDeclaration | externFunctionDeclaration | pp {recoverUntil="extern_class_body_part_recover"}
private extern_class_body_part_recover ::= !('#else' | '#elseif' | '#end' | '#error' | '#if' | '@:build' | '@:autoBuild' | '@:debug' | '@:getter' | '@:keep' | '@:overload' | '@:macro' | '@:nodebug' | '@:ns' | '@:protected' | '@:require' | '@:setter' | 'dynamic' | 'function' | 'inline' | 'override' | 'private' | 'public' | 'static' | 'var' | '}' | MACRO_ID)

classDeclaration ::= macroClass* 'private'? 'class' componentName genericParam? inheritList? '{' classBody '}'
{pin=3 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass" implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"}
classBody ::= classBodyPart*
private classBodyPart ::= varDeclaration | functionDeclarationWithAttributes | pp {recoverUntil="class_body_part_recover"}
private class_body_part_recover ::= !('#else' | '#elseif' | '#end' | '#error' | '#if' | '@:build' | '@:autoBuild' | '@:debug' | '@:getter' | '@:keep' | '@:overload' | '@:macro' | '@:nodebug' | '@:ns' | '@:protected' | '@:require' | '@:setter' | 'dynamic' | 'function' | 'inline' | 'override' | 'private' | 'public' | 'static' | 'var' | '}' | MACRO_ID)

interfaceDeclaration ::= macroClass* externOrPrivate? 'interface' componentName genericParam? inheritList? '{' interfaceBody '}'
{pin=3 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass" implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"}
interfaceBody ::= interfaceBodyPart*
private interfaceBodyPart ::= varDeclaration | functionPrototypeDeclarationWithAttributes | pp {recoverUntil="interface_body_part_recover"}
private interface_body_part_recover ::= !('#else' | '#elseif' | '#end' | '#error' | '#if' | '@:build' | '@:autoBuild' | '@:debug' | '@:getter' | '@:keep' | '@:overload' | '@:macro' | '@:nodebug' | '@:ns' | '@:protected' | '@:require' | '@:setter' | 'dynamic' | 'function' | 'inline' | 'override' | 'private' | 'public' | 'static' | 'var' | '}' | MACRO_ID)

enumDeclaration ::= macroClass* externOrPrivate? 'enum' componentName genericParam? '{' enumBody '}'
{pin=3 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass" implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"}
enumBody ::= (pp | enumValueDeclaration)*

/*
 *  declarations
 */

access ::= 'public' | 'private'
declarationAttribute ::= 'static' | 'inline' | 'dynamic' | 'override' | access
declarationAttributeList ::= declarationAttribute+

enumValueDeclaration ::= componentName enumConstructorParameters? ';'
{recoverUntil="enum_value_declaration_recovery" mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}

private enum_value_declaration_recovery ::= !('#else' | '#elseif' | '#end' | '#error' | '#if' | ID | '}')

enumConstructorParameters ::= '(' parameterList? ')' {pin=1}

varDeclaration ::= macroMember* declarationAttributeList? 'var' varDeclarationPartList ';' {pin=3}
private varDeclarationPartList ::= varDeclarationPart (',' varDeclarationPart)*
varDeclarationPart ::= componentName propertyDeclaration? typeTag? varInit?
{recoverUntil="var_declaration_part_recover" mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}
private var_declaration_part_recover ::= !(';' | ',')

localVarDeclaration ::= 'var' localVarDeclarationPartList ';'? {pin=1 }
private localVarDeclarationPartList ::= localVarDeclarationPart (',' localVarDeclarationPart)*
localVarDeclarationPart ::= componentName propertyDeclaration? typeTag? varInit?
{recoverUntil="local_var_declaration_part_recover" mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}
private local_var_declaration_part_recover ::= !(';' | ',' | '!' | '#else' | '#elseif' | '#end' | '#error' | '#if' | '(' | '++' | '-' | '--' | '[' | 'break' | 'case' | 'cast' | 'continue' | 'default' | 'do' | 'for' | 'function' | 'if' | 'new' | 'null' | 'return' | 'switch' | 'this' | 'super' | 'throw' | 'try' | 'untyped' | 'var' | 'while' | '{' | '~' | ID | LITCHAR | LITFLOAT | LITHEX | LITINT | LITOCT | LITSTRING)

propertyDeclaration ::= '(' propertyAccessor ',' propertyAccessor ')'

propertyAccessor ::= referenceExpression | 'null' | 'default' | 'dynamic' | 'never'

private functionCommonBody ::= blockStatement | returnStatementWithoutSemicolon | expression

externFunctionDeclaration ::= functionMacroMember* declarationAttributeList? 'function' ('new' | componentName genericParam?) '(' parameterList? ')' typeTag? 'untyped'? (functionCommonBody | ';')
{pin=4 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponentWithDeclarationList"}
functionDeclarationWithAttributes ::= functionMacroMember* declarationAttributeList? 'function' ('new' | componentName genericParam?) '(' parameterList? ')' typeTag? 'untyped'? functionCommonBody
{pin=4 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponentWithDeclarationList"}
functionPrototypeDeclarationWithAttributes ::= functionMacroMember* declarationAttributeList? 'function' ('new' | componentName genericParam?) '(' parameterList? ')' typeTag? 'untyped'? ';'
{pin=4 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponentWithDeclarationList"}
localFunctionDeclaration ::= 'function' componentName genericParam? '(' parameterList? ')' typeTag? 'untyped'? functionCommonBody
{pin=2 mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}
anonymousFunctionDeclaration ::= 'function' '(' parameterList? ')' typeTag? 'untyped'? '{' '}' {pin=2}
/*
 *
 */

varInit ::= '=' expression {pin=1}
parameter ::= '?'? componentName typeTag? varInit?
{mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}
private parameter_recovery ::= !(')' | ',')

parameterList ::= parameter (',' parameter)* {recoverUntil="parameterListRecovery"}
private parameterListRecovery ::= !')' // after parameterList always ')'

functionLiteral ::= 'function' '(' parameterList? ')' typeTag? 'untyped'? functionCommonBody {pin=2}
arrayLiteral ::= '[' expressionList? ']'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

private functionTypeWrapper ::= typeOrAnonymous functionType*
left functionType ::= '->' typeOrAnonymous

typeTag ::= ':' functionTypeWrapper
typeParam ::= '<' typeList '>'
typeList ::= typeListPart (',' typeListPart)*
genericParam ::= '<' genericListPart (',' genericListPart)* '>'
genericListPart ::= componentName (':' '(' typeList ')')?
{mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}
typeListPart ::= functionTypeWrapper
type ::= referenceExpression qualifiedReferenceExpression* typeParam?
typeOrAnonymous ::= type | anonymousType

blockStatement ::= '{' statementList? '}'
private statementList ::= (statement ';'?)+

private statement ::= blockStatement | notBlockStatement {recoverUntil="statement_recovery"}
private statement_recovery ::= !('!' | '#else' | '#elseif' | '#end' | '#error' | '#if' | '('
  | '++' | '-' | '--' | '[' | 'break' | 'case' | 'cast' | 'continue' | 'default' | 'do' | 'for'
  | 'function' | 'if' | 'new' | 'null' | 'return' | 'switch' | 'this' | 'super' | 'throw' | 'try' | 'untyped'
  | 'var' | 'while' | '{' | '~' | ID | LITCHAR | LITFLOAT | LITHEX | LITINT | LITOCT | LITSTRING
  | ';' | '}' | ')' | 'else')

private notBlockStatement ::= ('untyped' statement)
                            | localVarDeclaration
                            | localFunctionDeclaration
                            | ifStatement
                            | forStatement
                            | whileStatement
                            | doWhileStatement
                            | returnStatement
                            | breakStatement
                            | continueStatement
                            | caseStatement
                            | defaultStatement
                            | switchStatement
                            | throwStatement
                            | tryStatement
                            | (expression ';'?)
                            | pp

ifStatement ::= 'if' '(' expression ')' statement ('else' statement)?
ifExpression ::= 'if' '(' expression ')' expression (';'? 'else' expression)?

forStatement ::= 'for' '(' componentName 'in' iterable')' statement
{mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}

iterable ::= expression

whileStatement ::= 'while' '(' expression ')' statement
doWhileStatement ::= 'do' statement 'while' '(' expression ')'

returnStatement ::= 'return' expression? ';'
returnStatementWithoutSemicolon ::= 'return' expression

breakStatement ::= 'break' ';'
continueStatement ::= 'continue' ';'
defaultStatement ::= 'default' ':'

throwStatement ::= 'throw' expression ';'
caseStatement ::= 'case' expressionList ':'

switchStatement ::= 'switch' '(' expression ')' blockStatement
switchExpression ::= 'switch' '(' expression ')' blockStatement
tryExpression ::= 'try' expression catchExpression*
tryStatement ::= 'try' blockStatement catchStatement*
catchExpression ::= 'catch' '(' parameter ')' expression
catchStatement ::= 'catch' '(' parameter ')' blockStatement

/*
 * expressions
 */

expressionList ::= expression (',' expression)* {recoverUntil="expression_list_recover"}
private expression_list_recover ::= !(')' | ':' | ']')

expression ::= assignExpressionWrapper {recoverUntil="expression_recover"}
private expression_recover ::= !('!' | '!=' | '#else' | '#elseif' | '#end' | '#error' | '#if' | '%' | '%=' | '&&' | '&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '...' | '/' | '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '@:autoBuild' | '@:bind' | '@:bitmap' | '@:build' | '@:core_api' | '@:debug' | '@:fakeEnum' | '@:final' | '@:getter' | '@:hack' | '@:keep' | '@:overload' | '@:macro' | '@:meta' | '@:native' | '@:nodebug' | '@:ns' | '@:protected' | '@:require' | '@:setter' | '[' | ']' | '^' | '^=' | 'break' | 'case' | 'cast' | 'catch' | 'class' | 'continue' | 'default' | 'do' | 'dynamic' | 'else' | 'enum' | 'extern' | 'false' | 'for' | 'function' | 'if' | 'import' | 'inline' | 'interface' | 'new' | 'null' | 'override' | 'private' | 'public' | 'return' | 'static' | 'super' | 'switch' | 'this' | 'throw' | 'true' | 'try' | 'typedef' | 'untyped' | 'using' | 'var' | 'while' | '{' | '|' | '|=' | '||' | '}' | '~' | ID | LITCHAR | LITFLOAT | LITHEX | LITINT | LITOCT | LITSTRING | MACRO_ID)

private assignExpressionWrapper ::= iteratorExpressionWrapper assignExpression*
left assignExpression ::= assignOperation iteratorExpressionWrapper {pin=1 extends="expression"}

private iteratorExpressionWrapper ::= ternaryExpressionWrapper iteratorExpression?
left iteratorExpression ::= '...' ternaryExpressionWrapper

private ternaryExpressionWrapper ::= logicOrExpressionWrapper ternaryExpression?
left ternaryExpression ::= '?' expression ':' ternaryExpressionWrapper

private logicOrExpressionWrapper ::= logicAndExpressionWrapper logicOrExpression*
left logicOrExpression ::= '||' logicAndExpressionWrapper

private logicAndExpressionWrapper ::= compareExpressionWrapper logicAndExpression*
left logicAndExpression ::= '&&' compareExpressionWrapper

private compareExpressionWrapper ::= bitwiseExpressionWrapper compareExpression*
left compareExpression ::= compareOperation bitwiseExpressionWrapper

private bitwiseExpressionWrapper ::= shiftExpressionWrapper bitwiseExpression*
left bitwiseExpression ::= bitOperation shiftExpressionWrapper

private shiftExpressionWrapper ::= additiveExpressionWrapper shiftExpression*
left shiftExpression ::= shiftOperator additiveExpressionWrapper

private additiveExpressionWrapper ::= multiplicativeExpressionWrapper additiveExpression*
left additiveExpression ::= ('+' | '-') multiplicativeExpressionWrapper

private multiplicativeExpressionWrapper ::= prefixExpression multiplicativeExpression*
left multiplicativeExpression ::= ('*' | '/' | '%') (prefixExpression | suffixExpressionWrapper)

prefixExpression ::= ('-' | '--' | '++' | '!' | '~') prefixExpression | suffixExpressionWrapper

private suffixExpressionWrapper ::= value suffixExpression*
left suffixExpression ::= ('--' | '++')

private value ::= 'untyped' value
                | (literalExpression qualifiedReferenceTail?)
                | ifExpression
                | switchExpression
                | tryExpression
                | ppIfValue
                | castExpression
                | newExpressionOrCall
                | parenthesizedExpressionOrCall
                | callOrArrayAccess

ppIfValue ::= ppIf expression (ppElseIf expression)* ppElse expression ppEnd {pin=4}

literalExpression ::= LITINT | LITHEX | LITOCT | LITFLOAT | LITSTRING | LITCHAR
                    | regularExpressionLiteral
                    | 'null' | 'true' | 'false'
                    | functionLiteral
                    | arrayLiteral
                    | objectLiteral
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

regularExpressionLiteral ::= REG_EXP
{extends="literalExpression" mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeRegularExpressionImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeRegularExpression"}

private parenthesizedExpressionOrCall ::= parenthesizedExpression qualifiedReferenceTail?
parenthesizedExpression ::= '(' (expression | statement) ')'

private newExpressionOrCall ::= newExpression qualifiedReferenceTail?
private qualifiedReferenceTail ::= qualifiedReferenceExpression (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*

private callOrArrayAccess ::= (referenceExpression | thisExpression | superExpression) (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*

left callExpression ::= '(' expressionList? ')'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}
left arrayAccessExpression ::= '[' expression? ']'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

referenceExpression ::= identifier
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}
left qualifiedReferenceExpression ::= '.' referenceExpression {elementType="referenceExpression"}
simpleQualifiedReferenceExpression ::= referenceExpression qualifiedReferenceExpression * {elementType="referenceExpression"}
componentName ::= identifier
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeNamedElementImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeNamedElement"}
identifier ::= ID

thisExpression ::= 'this'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

superExpression ::= 'super'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

newExpression ::= 'new' type '(' expressionList? ')'
{pin=2 mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

castExpression ::= 'cast' (('(' expression ',' functionTypeWrapper ')')  | expression)

inheritList ::= inherit (',' inherit)*

inherit ::= ('extends' | 'implements') type {pin=1 recoverUntil="inherit_recover"}
private inherit_recover ::= !(',' | '{')

anonymousType ::= '{' anonymousTypeBody '}'
{pin=3 mixin="com.intellij.plugins.haxe.lang.psi.impl.AnonymousHaxeTypeImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"}

anonymousTypeBody ::= extendedAnonymousTypeBody | simpleAnonymousTypeBody | interfaceBody
private extendedAnonymousTypeBody ::= typeExtends (',' anonymousTypeFieldList)? (',' interfaceBody)?
private simpleAnonymousTypeBody ::= anonymousTypeFieldList (',' interfaceBody)?

typeExtends ::= '>' type

anonymousTypeFieldList ::= anonymousTypeField (',' anonymousTypeField)*

anonymousTypeField ::= componentName typeTag
{mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent" implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"}

objectLiteral ::= '{' objectLiteralElementList? '}'

private objectLiteralElementList ::= objectLiteralElement (',' objectLiteralElement)*

objectLiteralElement ::= identifier ':' expression







